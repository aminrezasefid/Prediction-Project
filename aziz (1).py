# -*- coding: utf-8 -*-
"""aziz.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DU2m84awqk2dZ_TIkZNT8VcoxOvaZyt1
"""

!pip install -q torch-scatter -f https://pytorch-geometric.com/whl/torch-1.9.0+cu102.html
!pip install -q torch-sparse -f https://pytorch-geometric.com/whl/torch-1.9.0+cu102.html
!pip install -q git+https://github.com/rusty1s/pytorch_geometric.git

import pandas as pd
import torch
from torch_geometric.data import Data

import requests
from os import getcwd

url = "https://raw.githubusercontent.com/jokecamp/FootballData/master/EPL%202011-2019/PL_scraped_ord.csv"
# current_directory = getcwd()
filename = 'dataset.txt'
req = requests.get(url)
if req.status_code == 200:
  with open(filename, 'wb') as fp:
    fp.write(req.content)

df = pd.read_csv(filename, encoding='latin-1', usecols=['home_team', 'away_team', 'result', 'home_lineup', 'away_lineup'])

# pd.read_csv(filename, encoding='latin-1')['match_week']

corrupted = df.loc[pd.isna(df['away_lineup']) | pd.isna(df['home_lineup'])]

corrupted

df = df.drop(corrupted.index, axis=0)

df.shape

DF = df.loc[df.index[:19]]

DF

def stats(df, show_players=False, show_teams=False, show_results=False):
  from collections import OrderedDict as od
  players_set = set()
  players_list = list()
  teams_set = set()
  teams_list = list()
  results = dict()
  for index, (h_team, a_team, result, h_lineup, a_lineup) in df.iterrows():
    home_players = h_lineup[:-4].split(' - ')
    away_players = a_lineup[:-4].split(' - ')
    players_set.update(home_players + away_players)
    players_list.extend(home_players + away_players)
    if result == 'home':
      results.update({f'{h_team} #Wins': results.get(f'{h_team} #Wins', 0)+1})
      results.update({f'{a_team} #Losses': results.get(f'{a_team} #Losses', 0)+1})
    elif result == 'tie':
      results.update({f'{h_team} #Ties': results.get(f'{h_team} #Ties', 0)+1})
      results.update({f'{a_team} #Ties': results.get(f'{a_team} #Ties', 0)+1})
    else:
      results.update({f'{a_team} #Wins': results.get(f'{a_team} #Wins', 0)+1})
      results.update({f'{h_team} #Losses': results.get(f'{h_team} #Losses', 0)+1})

    teams_list.extend([h_team, a_team])
    teams_set.update([h_team, a_team])
    
  if show_players:
    for player in players_set:
      print(f'{player} played in {players_list.count(player)} matches.')
  if show_teams:
    for team in teams_set:
      print(f'{team} played {teams_list.count(team)} matches.')
  if show_results:
    results = od(sorted(results.items()))
    for key, val in results.items():
      print(f'{key}: {val}')

# stats(df.loc[df.index[:30]], show_teams=True)

def show_edges(df, edge, edge_type):
  types = {
      1: 'Won',
      2: 'Lost To',
      3: 'Tied With',
      4: 'Played For',
      5: 'Used As Player',
      6: 'Is Before',
      7: 'Is After'
  }
  nodes = nodes_gen(df)
  r = {k:v for v, k in nodes.items()}
  for i in range(edge_type.shape[0]):
    head = int(edge[0][i].item())
    tail = int(edge[1][i].item())
    relation = int(edge_type[i].item())
    arrow = f'=== {types[relation]} ===>'
    print(f'{r[head]:<32}   {arrow}   {r[tail]:>32}')

WON = 1
LOST_TO = 2
TIED_WITH = 3
PLAYED_IN = 4
USED = 5
BEFORE = 6
AFTER = 7

def remove_redundancy(players):
  new_players = list()

  for player in players:
    if 'Own' in player:
      # print(player)
      player = player.replace('Own', '')
    if 'Pen. Scored' in player:
      # print(player)
      player = player.replace('Pen. Scored', '')
    if 'Pen. Score' in player:
      # print(player)
      player = player.replace('Pen. Score', '')
    if 'Own' in player or 'Scored' in player or '.' in player or 'Score' in player:
      print(player)
      #SHOULD NOT PRINT IF CODE IS CORRECT
    else:
      new_players.append(player.strip())
  return new_players

def nodes_gen(df):
  from collections import OrderedDict as od
  nodes = dict()

  node_counter = 1

  for index, (h_team, a_team, result, h_lineup, a_lineup) in df.iterrows():
      home_players = h_lineup[:-4].split(' - ')
      away_players = a_lineup[:-4].split(' - ')

      home_players = remove_redundancy(home_players)
      away_players = remove_redundancy(away_players)

      for player_index, player in enumerate(home_players):
        nodes[f'{player}@{index}'] = node_counter
        node_counter += 1
      for player_index, player in enumerate(away_players):
        nodes[f'{player}@{index}'] = node_counter
        node_counter += 1

      nodes[f'{h_team}*{index}'] = node_counter
      node_counter += 1

      nodes[f'{a_team}*{index}'] = node_counter
      node_counter += 1

  return od(sorted(nodes.items()))

# nodes_gen(DF)

def home_won_gen(df):
  nodes = nodes_gen(df)

  home_winning_matches = df.loc[df['result'] == 'home']
  home_winners = home_winning_matches['home_team']
  away_losers = home_winning_matches['away_team']

  winning_hashes = list()
  losing_hashes = list()

  for home, away, match in zip(home_winners, away_losers, home_winners.index):
    winning_hashes.append(f'{home}*{match}')
    losing_hashes.append(f'{away}*{match}')

  winning_nodes = list()
  losing_nodes = list()

  for winner, loser in zip(winning_hashes, losing_hashes):
    winning_nodes.append(nodes[winner]) 
    losing_nodes.append(nodes[loser])

  won_edges = torch.tensor(
      [
      winning_nodes,
      losing_nodes
      ]
  )

  lost_edges = torch.tensor(
      [
      losing_nodes,
      winning_nodes
      ]
  )

  won_edge_types = torch.ones(won_edges.shape[1]) * WON
  lost_edge_types = torch.ones(lost_edges.shape[1]) * LOST_TO 

  return won_edges, won_edge_types, lost_edges, lost_edge_types

# a, b, c, d = home_won_gen(DF)
# show_edges(DF, c, d)

def away_won_gen(df):
  nodes = nodes_gen(df)

  away_winning_matches = df.loc[df['result'] == 'away']
  away_winners = away_winning_matches['away_team']
  home_losers = away_winning_matches['home_team']

  winning_hashes = list()
  losing_hashes = list()

  for home, away, match in zip(home_losers, away_winners, away_winners.index):
    winning_hashes.append(f'{away}*{match}')
    losing_hashes.append(f'{home}*{match}')

  winning_nodes = list()
  losing_nodes = list()

  for winner, loser in zip(winning_hashes, losing_hashes):
    winning_nodes.append(nodes[winner]) 
    losing_nodes.append(nodes[loser])

  won_edges = torch.tensor(
      [
      winning_nodes,
      losing_nodes
      ]
  )

  lost_edges = torch.tensor(
      [
      losing_nodes,
      winning_nodes
      ]
  )
  
  won_edge_types = torch.ones(won_edges.shape[1]) * WON
  lost_edge_types = torch.ones(lost_edges.shape[1]) * LOST_TO 
  
  return won_edges, won_edge_types, lost_edges, lost_edge_types

# a, b, c, d = away_won_gen(DF)
# show_edges(DF, c, d)

def tied_gen(df):
  nodes = nodes_gen(df)

  tied_matches = df.loc[df['result'] == 'tie']
  home_teams = tied_matches['home_team']
  away_teams = tied_matches['away_team']

  home_hashes = list()
  away_hashes = list()

  for home, away, match in zip(home_teams, away_teams, away_teams.index):
    away_hashes.append(f'{away}*{match}')
    home_hashes.append(f'{home}*{match}')

  home_nodes = list()
  away_nodes = list()

  for home, away in zip(home_hashes, away_hashes):
    home_nodes.append(nodes[home]) 
    away_nodes.append(nodes[away])

  home_tied_edges = torch.tensor(
      [
      home_nodes,
      away_nodes
      ]
  )

  away_tied_edges = torch.tensor(
      [
      away_nodes,
      home_nodes
      ]
  )

  home_tied_edge_types = torch.ones(home_tied_edges.shape[1]) * TIED_WITH
  away_tied_edge_types = torch.ones(away_tied_edges.shape[1]) * TIED_WITH

  return home_tied_edges, home_tied_edge_types, away_tied_edges, away_tied_edge_types

# a, b, c, d = tied_gen(DF)
# show_edges(DF, a, b)
# show_edges(DF, c, d)

def played_used_gen(df):
  nodes = nodes_gen(df)

  team_nodes = list()
  player_nodes = list()

  for index, (h_team, a_team, result, h_lineup, a_lineup) in df.iterrows():
    home_players = h_lineup[:-4].split(' - ')
    away_players = a_lineup[:-4].split(' - ')

    home_players = remove_redundancy(home_players)
    away_players = remove_redundancy(away_players)

    for home_player, away_player in zip(home_players, away_players):
      player_nodes.append(nodes[f'{home_player}@{index}'])
      team_nodes.append(nodes[f'{h_team}*{index}'])
      player_nodes.append(nodes[f'{away_player}@{index}'])
      team_nodes.append(nodes[f'{a_team}*{index}'])

  played_in_edges = torch.tensor(
      [
       player_nodes,
       team_nodes
      ]
  )

  played_in_edge_types = torch.ones(played_in_edges.shape[1]) * PLAYED_IN

  used_edges = torch.tensor(
      [
       team_nodes,
       player_nodes
      ]
  ) 

  used_edge_types = torch.ones(used_edges.shape[1]) * USED

  return played_in_edges, played_in_edge_types, used_edges, used_edge_types

# a, b, c, d = played_used_gen(DF)
# show_edges(DF, a, b)
# show_edges(DF, c, d)

#TODO
def players_before_after_gen(df):
  nodes = nodes_gen(df)
  keys = list(nodes.keys())
  player_match_hashes = list(filter(lambda key: ('@' in key), keys))

  sorted_hashes = sorted(
      player_match_hashes,
      key= lambda w: (w.split('@')[0], int(w.split('@')[1]))
  )

  # print(s)

  r = {k:v for v, k in nodes.items()}

  before_nodes = list()
  after_nodes = list()

  for index, hash in enumerate(sorted_hashes):
    player, match = hash.split('@')
    before_node = nodes[hash]
    try:
      after_node = nodes[sorted_hashes[index+1]]
      if r[before_node].split('@')[0] == r[after_node].split('@')[0]:
        before_nodes.append(before_node)
        after_nodes.append(after_node)
        
    except:
      pass
  before_edges = torch.tensor(
      [
      before_nodes,
      after_nodes
      ]
  )

  before_edge_types = torch.ones(before_edges.shape[1]) * BEFORE

  after_edges = torch.tensor(
      [
      after_nodes,
      before_nodes
      ]
  )

  after_edge_types = torch.ones(after_edges.shape[1]) * AFTER

  return before_edges, before_edge_types, after_edges, after_edge_types

a, b, c, d = players_before_after_gen(DF)
show_edges(DF, a, b)
# show_edges(DF, c, d)

def teams_before_after_gen(df):
  nodes = nodes_gen(df)
  keys = list(nodes.keys())
  team_match_hashes = list(filter(lambda key: ('*' in key), keys))

  sorted_hashes = sorted(
      team_match_hashes,
      key= lambda w: (w.split('*')[0], int(w.split('*')[1]))
  )

  r = {k:v for v, k in nodes.items()}

  before_nodes = list()
  after_nodes = list()

  for index, hash in enumerate(sorted_hashes):
    team, match = hash.split('*')
    before_node = nodes[hash]
    try:
      after_node = nodes[sorted_hashes[index+1]]
      if r[before_node].split('*')[0] == r[after_node].split('*')[0]:
        before_nodes.append(before_node)
        after_nodes.append(after_node)
        
    except:
      pass
  before_edges = torch.tensor(
      [
      before_nodes,
      after_nodes
      ]
  )

  before_edge_types = torch.ones(before_edges.shape[1]) * BEFORE

  after_edges = torch.tensor(
      [
      after_nodes,
      before_nodes
      ]
  )

  after_edge_types = torch.ones(after_edges.shape[1]) * AFTER

  return before_edges, before_edge_types, after_edges, after_edge_types

# a, b, c, d = teams_before_after_gen(DF)
# # show_edges(DF, a, b)
# show_edges(DF, c, d)

def graph_gen(df, for_players=True, for_teams=True):
  home_win, won1, away_lost, lost1 = home_won_gen(df)
  away_won, won2, home_lost, lost2 = away_won_gen(df)
  home_tied, tied1, away_tied, tied2 = tied_gen(df)
  player_played, played1, team_used, used1 = played_used_gen(df)

  edge_index = torch.cat(
        (home_win, away_lost, away_won, home_lost, home_tied, away_tied, player_played, team_used),
        dim=1
    )
  
  edge_type = torch.cat(
        (won1, lost1, won2, lost2, tied1, tied2, played1, used1)
    )

  if for_players:
    player_before, before1, player_after, after1 = players_before_after_gen(df)
    edge_index = torch.cat((edge_index, player_before, player_after), dim=1)
    edge_type = torch.cat((edge_type, before1, after1))
  if for_teams:
    team_before, before2, team_after, after2 = teams_before_after_gen(df)
    edge_index = torch.cat((edge_index, team_before, team_after), dim=1)
    edge_type = torch.cat((edge_type, before2, after2))

  return edge_index, edge_type

# e, t = graph_gen(DF, True, False)
# show_edges(DF, e, t)

def home_result(row):
  if row == 'home':
    return WON
  elif row == 'tie':
    return TIED_WITH
  elif row == 'away':
    return LOST_TO

def data_gen(df, for_players=True, for_teams=True, print_edges=False):
  edge_index, edge_type = graph_gen(df, for_players, for_teams)
  if print_edges:
    show_edges(df, edge_index, edge_type)
  y = torch.tensor(df['result'].map(home_result).values)
  x = torch.tensor(list(range(len(nodes_gen(df)))))
  data = Data(x=x, y=y, edge_index=edge_index, edge_type = edge_type)
  return data

d = data_gen(df)
# stats(DF, True, True, True)
d.x

stats(df.loc[df.index[:299]], show_teams=True)

E=(128 * 160000) @ o=(160000 * 1)

class model(torch.nn.Module):
  def __init__(self):
    super().__init__()
    self.l = torch.nn.Embedding(10000, 15)

  def forward(self, x):
    return l(x)

m = model()
for name, tensor in m.named_parameters():
  print(name, tensor.shape